import React, { useState, useEffect } from 'react';
import { Tabs, Tab, Box } from '@mui/material';
import { useNavigate } from 'react-router-dom';
import { TableRenderer } from './TableRenderer';
import { ListRenderer } from './ListRenderer';
import { CardRenderer } from './CardRenderer';
import { BannerRenderer } from './BannerRenderer';
import { MapRenderer } from './MapRenderer';
import { tableService, type RenderableTableData } from '../services/table-service';
import { cardService, type RenderableCard } from '../services/card-service';
import type { ViewSpec, TabSpec, BlockSpec, CardSpec, TableSpec, ListSpec, MapSpec } from '../views/types';
import { TABLE_LIST_PRESETS } from '../config/table-list-presets';
import { getViewSourceTable } from '../views/view-table-mapping';
import { useDialog } from '@/shared/components/ConfirmDialog';
import { supabase } from '@/core/supabase/client';

export type DetailsRendererProps = {
  view: ViewSpec;
  entityId: string;
  className?: string;
};

export const DetailsRenderer: React.FC<DetailsRendererProps> = ({
  view,
  entityId,
  className = '',
}) => {
  const [activeTab, setActiveTab] = useState(0);
  const tabs = view.tabs;
  const sourceTable = getViewSourceTable(view.id);

  return (
    <div className={`details-renderer ${className}`}>
      {/* Banner (if specified) */}
      {view.banner && (
        <BannerRenderer
          banner={view.banner}
          entityId={entityId}
          sourceTable={sourceTable}
          fieldMetadata={view.fieldMetadata}
        />
      )}

      {/* Tabs */}
      {tabs.length === 1 ? (
        // Single tab - render directly without tab headers
        <TabContent tab={tabs[0]} entityId={entityId} sourceTable={sourceTable} fieldMetadata={view.fieldMetadata} />
      ) : (
        // Multiple tabs
        <Box>
          <Tabs
            value={activeTab}
            onChange={(_, newValue) => setActiveTab(newValue)}
            sx={{
              '& .MuiTab-root': {
                textTransform: 'none',
              }
            }}
          >
            {tabs.map((tab, index) => (
              <Tab key={tab.id} label={tab.label} />
            ))}
          </Tabs>
          {tabs.map((tab, index) => (
            <div
              key={tab.id}
              role="tabpanel"
              hidden={activeTab !== index}
              className="mt-4"
            >
              {activeTab === index && (
                <TabContent tab={tab} entityId={entityId} sourceTable={sourceTable} fieldMetadata={view.fieldMetadata} />
              )}
            </div>
          ))}
        </Box>
      )}
    </div>
  );
};

type TabContentProps = {
  tab: TabSpec;
  entityId: string;
  sourceTable: string;
  fieldMetadata?: import('../types/detail-types').FieldMetadataMap;
};

const TabContent: React.FC<TabContentProps> = ({ tab, entityId, sourceTable, fieldMetadata }) => {
  return (
    <div style={{ display: 'flex', flexWrap: 'wrap', gap: 24 }}>
      {tab.blocks.map((block, index) => (
        <BlockRenderer
          key={index}
          block={block}
          entityId={entityId}
          sourceTable={sourceTable}
          fieldMetadata={fieldMetadata}
        />
      ))}
    </div>
  );
};

type BlockRendererProps = {
  block: BlockSpec;
  entityId: string;
  sourceTable: string;
  fieldMetadata?: import('../types/detail-types').FieldMetadataMap;
};

const BlockRenderer: React.FC<BlockRendererProps> = ({ block, entityId, sourceTable, fieldMetadata }) => {
  const [isVisible, setIsVisible] = useState(true);

  // TODO: Implement visibility logic

  if (!isVisible) return null;

  // Get title from preset for table/list blocks
  let title: string | undefined;
  if (block.kind === 'table' || block.kind === 'list') {
    const preset = TABLE_LIST_PRESETS[block.preset as keyof typeof TABLE_LIST_PRESETS];
    title = preset?.title;
  } else {
    title = block.title;
  }

  // Determine width - default is 'half' for cards, 'full' for tables
  const width = block.width ?? (block.kind === 'table' ? 'full' : 'half');

  const containerStyle: React.CSSProperties = {
    flex: width === 'full' ? '1 1 100%' : '1 1 calc(50% - 12px)',
    minWidth: width === 'full' ? '100%' : '260px',
  };

  return (
    <div style={containerStyle}>
      {/* Title is now handled inside each renderer component */}

      {block.kind === 'table' && (
        <TableBlockRenderer
          block={block as TableSpec}
          entityId={entityId}
          fieldMetadata={fieldMetadata}
        />
      )}

      {block.kind === 'list' && (
        <ListBlockRenderer
          block={block as ListSpec}
          entityId={entityId}
          fieldMetadata={fieldMetadata}
        />
      )}

      {block.kind === 'card' && (
        <CardBlockRenderer
          block={block as CardSpec}
          entityId={entityId}
          sourceTable={sourceTable}
          fieldMetadata={fieldMetadata}
        />
      )}

      {block.kind === 'map' && (
        <MapBlockRenderer
          block={block as MapSpec}
          entityId={entityId}
          sourceTable={sourceTable}
          fieldMetadata={fieldMetadata}
        />
      )}
    </div>
  );
};

// Table Block Renderer
const TableBlockRenderer: React.FC<{
  block: TableSpec;
  entityId: string;
  fieldMetadata?: import('../types/detail-types').FieldMetadataMap;
}> = ({ block, entityId, fieldMetadata }) => {
  const [tableData, setTableData] = useState<RenderableTableData | null>(null);

  useEffect(() => {
    loadTableData();
  }, [block.preset, entityId]);

  const loadTableData = async () => {
    if (!block.preset) return;

    try {
      setTableData({ ...tableData!, loading: true });
      const data = await tableService.loadTableData(
        block.preset,
        entityId,
        block.module,
        block.activeFilter,
        undefined,
        undefined,
        fieldMetadata
      );
      setTableData(data);
    } catch (error) {
      console.error('Failed to load table data:', error);
      setTableData({
        spec: { readSource: '', columns: [], rowActions: [] },
        rows: [],
        loading: false,
        error: error instanceof Error ? error.message : 'Unknown error',
      });
    }
  };

  const handleEdit = async (rowId: any, field: string, value: any) => {
    // TODO: Implement edit logic
    console.log('Edit:', rowId, field, value);
  };

  const dialog = useDialog();
  const navigate = useNavigate();

  const handleRowAction = async (rowId: any, actionId: string) => {
    const entity = view.entity as 'educator' | 'school' | 'charter';

    try {
      switch (actionId) {
        case 'view_in_modal':
        case 'jump_to_modal':
          navigate(`/${entity}s/${rowId}`);
          break;
        case 'email':
          // For now, just navigate to compose page
          // TODO: Get email addresses from row data
          if (typeof window !== 'undefined') {
            window.location.assign(`/email/compose?entityId=${rowId}&entityType=${entity}`);
          }
          break;
        default:
          await dialog.alert('This action is not implemented yet for list items.', {
            title: 'Not Implemented',
            variant: 'warning',
          });
          break;
      }
    } catch (error) {
      console.error('Row action error:', error);
      await dialog.alert('Unable to complete the request.', {
        title: 'Error',
        variant: 'error',
      });
    }
  };

  const handleTableAction = async (actionId: string) => {
    // TODO: Implement table action logic
    console.log('Table action:', actionId);
  };

  if (!tableData) {
    return <div>Loading table...</div>;
  }

  return (
    <TableRenderer
      data={tableData}
      onEdit={handleEdit}
      onRowAction={handleRowAction}
      onTableAction={handleTableAction}
    />
  );
};

// List Block Renderer
const ListBlockRenderer: React.FC<{
  block: ListSpec;
  entityId: string;
  fieldMetadata?: import('../types/detail-types').FieldMetadataMap;
}> = ({ block, entityId, fieldMetadata }) => {
  const [listData, setListData] = useState<import('../services/card-service').RenderableListData | null>(null);

  useEffect(() => {
    loadListData();
  }, [block.preset, entityId]);

  const loadListData = async () => {
    if (!block.preset) return;

    try {
      setListData({ ...listData!, loading: true, rows: [], preset: block.preset });
      const data = await cardService.loadListData(
        block.preset,
        entityId,
        block.module,
        block.activeFilter,
        fieldMetadata
      );
      setListData(data);
    } catch (error) {
      console.error('Failed to load list data:', error);
      setListData({
        preset: block.preset,
        rows: [],
        loading: false,
        error: error instanceof Error ? error.message : 'Unknown error',
      });
    }
  };

  const dialog = useDialog();
  const navigate = useNavigate();

  const handleRowAction = async (rowId: any, actionId: string) => {
    const entity = view.entity as 'educator' | 'school' | 'charter';

    try {
      switch (actionId) {
        case 'view_in_modal':
          // Go to a detail view modal for the exact record type in the table. If it's a join table, that means go to the record for the join itself - which could be an educator-school join in people_roles_associations or a guide assignment to a school or educator
        case 'jump_to_modal':
          // This is only available on join tables. If we're in a school detail view looking at the educators join table or board members join table, this means go to the educator detail view. Same in reverse. And for the guides tables that exist in the schools and educator details, open a modal of the guide themselves from the guides table
          navigate(`/${entity}s/${rowId}`);
          break;
        case 'email':
          // If this is called from a educators list, email that educator using the details_educators.primary_email. same for board members from that list container. if this is called from a guides/assignments list container, the email is in the field guides_assignments.email_or_name. if this is called from a school list, the emails are an array in details_schools.tl_primary_emails
          // Go to the compose email page and put the email addresses in the to field
        case 'archive':
          // Anywhere this is called, put up a confirmation dialog saying are you sure you want to archive it? It will no longer appear in any views. If they yes, flip it's is_archived property to true
        case 'add note':
          // I think you already created this for a table action. do the same thing here except fill in the column that connects to the entity type in the current table. the notes table has columns for people_id, school_id, charter_id, action_step_id, charter_application_id, governance_doc_id, grant_id, loan_id, location_id, nine_ninety_id, ssj_fillout_form_id, and montessori_cert_id and can be attached to any of those entities.
        case 'add task'
          // You already implement this for table actions too and it's exactly the same here
        case 'end_stint':
          // this applies to join tables only - when selected, add an end_date to the join and set is_active to false. this applies to educator to school joins and guide assingments
        case 'end_occupancy':
          // much like end_stint, but this applies to locations which are directly connected to schools but have start_date and end_date columns. 
        case 'make_primary':
          // this applies to email address tables - mark the one this was called on as is_primary true and all others for that person as false
        case 'toggle_complete':
          // this applies to action_steps - flip the is_complete boolean 
        case 'toggle_private_public':
          // this applies to notes, gmails, and gcals - flip the is_private boolean
      



          if (typeof window !== 'undefined') {
            window.location.assign(`/email/compose?entityId=${rowId}&entityType=${entity}`);
          }
          break;
        default:
          await dialog.alert('This action is not implemented yet for list items.', {
            title: 'Not Implemented',
            variant: 'warning',
          });
          break;
      }
    } catch (error) {
      console.error('Row action error:', error);
      await dialog.alert('Unable to complete the request.', {
        title: 'Error',
        variant: 'error',
      });
    }
  };

  const handleTableAction = async (actionId: string) => {
    // TODO: Implement table action logic
    console.log('Table action:', actionId);
  };

  if (!listData) {
    return <div>Loading list...</div>;
  }

  // Generate list layout from preset
  const preset = TABLE_LIST_PRESETS[block.preset as keyof typeof TABLE_LIST_PRESETS];
  const listLayout = generateListLayoutFromPreset(preset, block.width);

  return (
    <ListRenderer
      data={listData}
      layout={listLayout}
      onRowAction={handleRowAction}
      onTableAction={handleTableAction}
    />
  );
};

// Helper function to generate list layout from preset column listLayout values
function generateListLayoutFromPreset(preset: any, containerWidth?: 'half' | 'full') {
  if (!preset?.columns) return undefined;

  const layout = {
    titleField: undefined as string | undefined,
    subtitleFields: [] as string[],
    bodyFields: [] as string[],
    badgeFields: [] as string[],
    footerFields: [] as string[],
    attachmentFields: [] as string[],
    hideLabelsForFields: [] as string[],
    logoField: undefined as string | undefined,
    bodyFieldFullWidth: false,
    containerWidth: containerWidth || 'half',
  } as any;

  for (const column of preset.columns) {
    if (typeof column === 'object' && column.listLayout) {
      switch (column.listLayout) {
        case 'title':
          layout.titleField = column.field;
          break;
        case 'subtitle':
          layout.subtitleFields.push(column.field);
          break;
        case 'body':
          layout.bodyFields.push(column.field);
          // If this field has listFieldFullWidth, add it to hideLabelsForFields
          if (column.listFieldFullWidth) {
            layout.hideLabelsForFields.push(column.field);
          }
          break;
        case 'badge':
          layout.badgeFields.push(column.field);
          break;
        case 'footer':
          layout.footerFields.push(column.field);
          break;
        case 'attachment':
          layout.attachmentFields.push(column.field);
          break;
        case 'logo':
          layout.logoField = column.field;
          break;
      }
    }
  }

  return layout;
}

// Map Block Renderer
const MapBlockRenderer: React.FC<{
  block: MapSpec;
  entityId: string;
  sourceTable: string;
  fieldMetadata?: import('../types/detail-types').FieldMetadataMap;
}> = ({ block, entityId, sourceTable, fieldMetadata }) => {
  return (
    <MapRenderer
      map={block}
      entityId={entityId}
      sourceTable={sourceTable}
      fieldMetadata={fieldMetadata}
    />
  );
};

// Card Block Renderer
const CardBlockRenderer: React.FC<{
  block: CardSpec;
  entityId: string;
  sourceTable: string;
  fieldMetadata?: import('../types/detail-types').FieldMetadataMap;
}> = ({ block, entityId, sourceTable, fieldMetadata }) => {
  const [cardData, setCardData] = useState<RenderableCard | null>(null);

  useEffect(() => {
    loadCardData();
  }, [block.fields, entityId]);

  const loadCardData = async () => {
    try {
      setCardData({ ...cardData!, loading: true });
      const data = await cardService.loadCardData(block, entityId, sourceTable, fieldMetadata);
      setCardData(data);
    } catch (error) {
      console.error('Failed to load card data:', error);
      setCardData({
        entityId,
        title: block.title,
        fields: [],
        editable: false,
        loading: false,
        error: error instanceof Error ? error.message : 'Unknown error',
      });
    }
  };

  const handleSave = async (changedValues: Record<string, any>) => {
    if (!cardData) return;

    try {
      await cardService.saveCardData(cardData, changedValues);
      // Reload the card data to reflect changes
      await loadCardData();
    } catch (error) {
      console.error('Failed to save card data:', error);
      throw error;
    }
  };

  if (!cardData) {
    return <div>Loading card...</div>;
  }

  return (
    <CardRenderer
      card={cardData}
      onSave={block.editable ? handleSave : undefined}
      layout="single-column"
    />
  );
};