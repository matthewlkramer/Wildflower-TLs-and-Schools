import fs from 'fs';
import path from 'path';

type EnumsMap = Record<string, string[]>;
type FieldEnumMap = Record<string, string>;

function read(rel: string): string { return fs.readFileSync(path.resolve(process.cwd(), rel), 'utf8'); }
function write(rel: string, content: string) {
  const p = path.resolve(process.cwd(), rel);
  fs.mkdirSync(path.dirname(p), { recursive: true });
  fs.writeFileSync(p, content, 'utf8');
}

function extractBlock(src: string, start: number): { block: string; end: number } | null {
  let i = start; while (i < src.length && src[i] !== '{') i++;
  if (i >= src.length) return null;
  let depth = 0; let out = '';
  for (; i < src.length; i++) {
    const ch = src[i]; out += ch;
    if (ch === '{') depth++; else if (ch === '}') { depth--; if (depth === 0) return { block: out, end: i + 1 }; }
  }
  return null;
}

function parseFromConstants(src: string): EnumsMap {
  const map: EnumsMap = {};
  const cIdx = src.indexOf('export const Constants');
  if (cIdx === -1) return map;
  const cBlock = extractBlock(src, cIdx); if (!cBlock) return map;
  const pubIdx = cBlock.block.indexOf('public:'); if (pubIdx === -1) return map;
  const pBlock = extractBlock(cBlock.block, pubIdx); if (!pBlock) return map;
  const eIdx = pBlock.block.indexOf('Enums:'); if (eIdx === -1) return map;
  const eBlock = extractBlock(pBlock.block, eIdx); if (!eBlock) return map;
  // Match entries key: ["a", "b", ...]
  const entryRe = /(?:"([^"]+)"|(\w+))\s*:\s*\[([^\]]*)\]/g;
  let m: RegExpExecArray | null;
  while ((m = entryRe.exec(eBlock.block))) {
    const key = (m[1] || m[2]) as string;
    const arr = m[3];
    const vals = Array.from(arr.matchAll(/"([^"]+)"/g)).map((x) => x[1]);
    map[key] = vals;
  }
  return map;
}

function parseFieldEnums(src: string): FieldEnumMap {
  const res: FieldEnumMap = {};
  const pIdx = src.indexOf('public:'); if (pIdx === -1) return res;
  const pBlock = extractBlock(src, pIdx); if (!pBlock) return res;
  const tIdx = pBlock.block.indexOf('Tables:'); if (tIdx === -1) return res;
  const tBlock = extractBlock(pBlock.block, tIdx); if (!tBlock) return res;
  const tableRe = /(\w+)\s*:\s*\{[\s\S]*?Row:\s*\{([\s\S]*?)\}/g;
  let m: RegExpExecArray | null;
  while ((m = tableRe.exec(tBlock.block))) {
    const table = m[1]; const rowBody = m[2];
    const colRe = /(\w+)\s*:\s*([^\n;]+)/g; let c: RegExpExecArray | null;
    while ((c = colRe.exec(rowBody))) {
      const col = c[1]; const typeStr = c[2];
      const em = typeStr.match(/Database\[\"public\"\]\[\"Enums\"\]\[\"([^\"]+)\"\]/);
      if (em) res[`public.${table}.${col}`] = em[1];
    }
  }
  return res;
}

function generate() {
  const srcPath = path.join('src', 'types', 'database.types.ts');
  const outPath = path.join('src', 'modules', 'shared', 'enums.generated.ts');
  const src = read(srcPath);
  const enums = parseFromConstants(src);
  const fields = parseFieldEnums(src);
  const file = `// AUTO-GENERATED by scripts/generate-enums-from-constants.ts. Do not edit.
export const ENUM_OPTIONS: Record<string, readonly string[]> = ${JSON.stringify(enums, null, 2)};
export const FIELD_ENUMS: Record<string, string> = ${JSON.stringify(fields, null, 2)};
`;
  write(outPath, file);
  console.log(`Wrote ${outPath} with ${Object.keys(enums).length} enums and ${Object.keys(fields).length} fields.`);
}

generate();

