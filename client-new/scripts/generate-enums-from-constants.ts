import fs from 'fs';
import path from 'path';

type EnumsMap = Record<string, string[]>;
type FieldEnumMap = Record<string, string>;

function read(rel: string): string { return fs.readFileSync(path.resolve(process.cwd(), rel), 'utf8'); }
function write(rel: string, content: string) {
  const p = path.resolve(process.cwd(), rel);
  fs.mkdirSync(path.dirname(p), { recursive: true });
  fs.writeFileSync(p, content, 'utf8');
}

function extractBlock(src: string, start: number): { block: string; end: number } | null {
  let i = start; while (i < src.length && src[i] !== '{') i++;
  if (i >= src.length) return null;
  let depth = 0; let out = '';
  for (; i < src.length; i++) {
    const ch = src[i]; out += ch;
    if (ch === '{') depth++; else if (ch === '}') { depth--; if (depth === 0) return { block: out, end: i + 1 }; }
  }
  return null;
}

function parseFromConstants(src: string): EnumsMap {
  const map: EnumsMap = {};
  const cIdx = src.indexOf('export const Constants');
  if (cIdx === -1) return map;
  const cBlock = extractBlock(src, cIdx); if (!cBlock) return map;
  const pubIdx = cBlock.block.indexOf('public:'); if (pubIdx === -1) return map;
  const pBlock = extractBlock(cBlock.block, pubIdx); if (!pBlock) return map;
  const eIdx = pBlock.block.indexOf('Enums:'); if (eIdx === -1) return map;
  const eBlock = extractBlock(pBlock.block, eIdx); if (!eBlock) return map;
  // Match entries key: ["a", "b", ...]
  const entryRe = /(?:"([^"]+)"|(\w+))\s*:\s*\[([^\]]*)\]/g;
  let m: RegExpExecArray | null;
  while ((m = entryRe.exec(eBlock.block))) {
    const key = (m[1] || m[2]) as string;
    const arr = m[3];
    const vals = Array.from(arr.matchAll(/"([^"]+)"/g)).map((x) => x[1]);
    map[key] = vals;
  }
  return map;
}

function parseFieldEnums(src: string): FieldEnumMap {
  const res: FieldEnumMap = {};
  const pIdx = src.indexOf('public:'); if (pIdx === -1) return res;
  const pBlock = extractBlock(src, pIdx); if (!pBlock) return res;
  const tIdx = pBlock.block.indexOf('Tables:'); if (tIdx === -1) return res;
  const tBlock = extractBlock(pBlock.block, tIdx); if (!tBlock) return res;

  // Iterate table entries by finding name: { ... } blocks at the top level of Tables
  const tablesSrc = tBlock.block;
  const nameRe = /(\w+)\s*:\s*\{/g;
  let m: RegExpExecArray | null;
  while ((m = nameRe.exec(tablesSrc))) {
    const tableName = m[1];
    const start = m.index + m[0].length - 1; // position at '{'
    const tableBlock = extractBlock(tablesSrc, start);
    if (!tableBlock) continue;
    // Find Row: { ... } inside this table block
    const rowIdx = tableBlock.block.indexOf('Row:');
    if (rowIdx === -1) { continue; }
    const rowBlock = extractBlock(tableBlock.block, rowIdx);
    if (!rowBlock) { continue; }
    // Scan fields in Row body
    const lines = rowBlock.block.split(/\r?\n/);
    for (const raw of lines) {
      const line = raw.trim();
      const m2 = line.match(/^(\w+)\s*:\s*([^;]+);?/);
      if (!m2) continue;
      const col = m2[1]; const typeStr = m2[2];
      const em = typeStr.match(/Database\[\"public\"\]\[\"Enums\"\]\[\"([^\"]+)\"\]/);
      if (em) res[`public.${tableName}.${col}`] = em[1];
    }
    // advance regex index to end of this table block to avoid overlapping
    nameRe.lastIndex = m.index + (tableBlock.end || 0);
  }
  return res;
}

function generate() {
  const srcPath = path.join('src', 'types', 'database.types.ts');
  const outPath = path.join('src', 'modules', 'shared', 'enums.generated.ts');
  const src = read(srcPath);
  const enums = parseFromConstants(src);
  const fields = parseFieldEnums(src);
  const file = `// AUTO-GENERATED by scripts/generate-enums-from-constants.ts. Do not edit.
export const ENUM_OPTIONS: Record<string, readonly string[]> = ${JSON.stringify(enums, null, 2)};
export const FIELD_ENUMS: Record<string, string> = ${JSON.stringify(fields, null, 2)};
`;
  write(outPath, file);
  console.log(`Wrote ${outPath} with ${Object.keys(enums).length} enums and ${Object.keys(fields).length} fields.`);
}

generate();
