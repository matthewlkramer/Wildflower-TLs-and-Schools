import fs from 'fs';
import path from 'path';

function readFile(rel: string): string {
  const p = path.resolve(process.cwd(), rel);
  return fs.readFileSync(p, 'utf8');
}

function writeFile(rel: string, content: string) {
  const p = path.resolve(process.cwd(), rel);
  fs.mkdirSync(path.dirname(p), { recursive: true });
  fs.writeFileSync(p, content, 'utf8');
}

type EnumsMap = Record<string, string[]>;
type FieldEnumMap = Record<string, string>; // key: schema.table.column => enumName

// Very lightweight parser tailored to Supabase's generated database.types.ts
function parseEnumsAndFields(source: string): { enums: EnumsMap; fields: FieldEnumMap } {
  const enums: EnumsMap = {};
  const fields: FieldEnumMap = {};

  // Extract the `public` schema block
  const publicStart = source.indexOf('public: {');
  if (publicStart === -1) return { enums, fields };
  let i = publicStart;
  let depth = 0;
  let publicBlock = '';
  for (; i < source.length; i++) {
    const ch = source[i];
    publicBlock += ch;
    if (ch === '{') depth++;
    else if (ch === '}') { depth--; if (depth === 0) break; }
  }

  // Extract Enums block
  const enumsIdx = publicBlock.indexOf('Enums:');
  if (enumsIdx !== -1) {
    let j = enumsIdx + 'Enums:'.length;
    // find opening { of Enums
    while (j < publicBlock.length && publicBlock[j] !== '{') j++;
    if (j < publicBlock.length && publicBlock[j] === '{') {
      let k = j;
      let edepth = 0;
      let enumsBlock = '';
      for (; k < publicBlock.length; k++) {
        const ch = publicBlock[k];
        enumsBlock += ch;
        if (ch === '{') edepth++;
        else if (ch === '}') { edepth--; if (edepth === 0) break; }
      }
      // Parse entries like any of:
      // name: "A" | "B" | "C"
      // name:
      //   | "A"
      //   | "B"
      //   | "C"
      const lines = enumsBlock.split(/\r?\n/);
      let currentName: string | null = null;
      let options: string[] = [];
      const flush = () => {
        if (currentName && options.length) enums[currentName] = options.slice();
        currentName = null;
        options = [];
      };
      for (const raw of lines) {
        const line = raw.trim();
        // New enum header line
        const head = line.match(/^(\w+):\s*(.*)$/);
        if (head) {
          // flush previous
          flush();
          currentName = head[1];
          const rest = head[2];
          if (rest) {
            // Extract all quoted literals on same line
            const matches = rest.match(/"([^"]+)"/g) || [];
            for (const m of matches) {
              const val = m.replace(/^"|"$/g, '');
              if (val) options.push(val);
            }
          }
          continue;
        }
        // Continuation line with a literal
        const cont = line.match(/^\|\s*"([^"]+)"/);
        if (cont && currentName) {
          options.push(cont[1]);
          continue;
        }
        // End of block handled by loop end
      }
      flush();
    }
  }

  // Extract Tables block
  const tablesIdx = publicBlock.indexOf('Tables:');
  if (tablesIdx !== -1) {
    let j = tablesIdx + 'Tables:'.length;
    while (j < publicBlock.length && publicBlock[j] !== '{') j++;
    if (j < publicBlock.length && publicBlock[j] === '{') {
      let k = j;
      let tdepth = 0;
      let tablesBlock = '';
      for (; k < publicBlock.length; k++) {
        const ch = publicBlock[k];
        tablesBlock += ch;
        if (ch === '{') tdepth++;
        else if (ch === '}') { tdepth--; if (tdepth === 0) break; }
      }
      // For each table, extract Row block and scan for Database["public"]["Enums"]["name"] occurrences
      const tableRe = /(\w+)\s*:\s*\{[\s\S]*?Row:\s*\{([\s\S]*?)\}/g;
      let m: RegExpExecArray | null;
      while ((m = tableRe.exec(tablesBlock))) {
        const tableName = m[1];
        const rowBody = m[2];
        const colRe = /(\w+)\s*:\s*([^\n;]+)/g;
        let cm: RegExpExecArray | null;
        while ((cm = colRe.exec(rowBody))) {
          const colName = cm[1];
          const typeStr = cm[2];
          const em = typeStr.match(/Database\["public"\]\["Enums"\]\["([^"]+)"\]/);
          if (em) {
            const enumName = em[1];
            const key = `public.${tableName}.${colName}`;
            fields[key] = enumName;
          }
        }
      }
    }
  }

  return { enums, fields };
}

function generate() {
  const srcPath = path.join('src', 'types', 'database.types.ts');
  const outPath = path.join('src', 'modules', 'shared', 'enums.generated.ts');
  const content = readFile(srcPath);
  const { enums, fields } = parseEnumsAndFields(content);

  const file = `// AUTO-GENERATED by scripts/generate-enums-map.ts. Do not edit.
export const ENUM_OPTIONS: Record<string, readonly string[]> = ${JSON.stringify(enums, null, 2)};
export const FIELD_ENUMS: Record<string, string> = ${JSON.stringify(fields, null, 2)};
`;
  writeFile(outPath, file);
  // eslint-disable-next-line no-console
  console.log(`Wrote ${outPath} with ${Object.keys(enums).length} enums and ${Object.keys(fields).length} fields.`);
}

generate();
