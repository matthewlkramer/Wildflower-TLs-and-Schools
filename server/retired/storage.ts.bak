import { base } from "./airtable-schema";
import type { 
  Educator, 
  School,
  EducatorSchoolAssociation,
  InsertEducator, 
  InsertSchool,
  InsertEducatorSchoolAssociation,
  Teacher,
  TeacherSchoolAssociation,
  InsertTeacher,
  InsertTeacherSchoolAssociation
} from "@shared/schema";

export interface IStorage {
  // Educator operations
  getEducators(): Promise<Educator[]>;
  getEducator(id: string): Promise<Educator | undefined>;
  getEducatorByEmail(email: string): Promise<Educator | undefined>;
  createEducator(educator: InsertEducator): Promise<Educator>;
  updateEducator(id: string, educator: Partial<InsertEducator>): Promise<Educator | undefined>;
  deleteEducator(id: string): Promise<boolean>;
  
  // School operations
  getSchools(): Promise<School[]>;
  getSchool(id: string): Promise<School | undefined>;
  createSchool(school: InsertSchool): Promise<School>;
  updateSchool(id: string, school: Partial<InsertSchool>): Promise<School | undefined>;
  deleteSchool(id: string): Promise<boolean>;
  
  // Educator-School Association operations
  getEducatorSchoolAssociations(): Promise<EducatorSchoolAssociation[]>;
  getEducatorAssociations(educatorId: string): Promise<EducatorSchoolAssociation[]>;
  getSchoolAssociations(schoolId: string): Promise<EducatorSchoolAssociation[]>;
  createEducatorSchoolAssociation(association: InsertEducatorSchoolAssociation): Promise<EducatorSchoolAssociation>;
  deleteEducatorSchoolAssociation(id: string): Promise<boolean>;

  // Legacy methods for backward compatibility
  getTeachers(): Promise<Teacher[]>;
  getTeacher(id: string): Promise<Teacher | undefined>;
  getTeacherByEmail(email: string): Promise<Teacher | undefined>;
  createTeacher(teacher: InsertTeacher): Promise<Teacher>;
  updateTeacher(id: string, teacher: Partial<InsertTeacher>): Promise<Teacher | undefined>;
  deleteTeacher(id: string): Promise<boolean>;
  getTeacherSchoolAssociations(): Promise<TeacherSchoolAssociation[]>;
  getTeacherAssociations(teacherId: string): Promise<TeacherSchoolAssociation[]>;
  createTeacherSchoolAssociation(association: InsertTeacherSchoolAssociation): Promise<TeacherSchoolAssociation>;
  deleteTeacherSchoolAssociation(id: string): Promise<boolean>;
}

export class AirtableStorage implements IStorage {
  // Helper method to transform Airtable record to Educator
  private transformEducatorRecord(record: any): Educator {
    const fields = record.fields;
    return {
      id: record.id,
      fullName: fields["Full Name"] || "",
      firstName: fields["First Name"] || undefined,
      lastName: fields["Last Name"] || undefined,
      middleName: fields["Middle Name"] || undefined,
      nickname: fields["Nickname"] || undefined,
      primaryPhone: fields["Primary phone"] || undefined,
      secondaryPhone: fields["Secondary phone"] || undefined,
      homeAddress: fields["Home Address"] || undefined,
      pronouns: fields["Pronouns"] || undefined,
      gender: fields["Gender"] || undefined,
      raceEthnicity: fields["Race & Ethnicity"] || undefined,
      primaryLanguage: fields["Primary Language"] || undefined,
      otherLanguages: fields["Other languages"] || undefined,
      educationalAttainment: fields["Educational Attainment"] || undefined,
      montessoriCertified: fields["Montessori Certified"] || false,
      certificationLevels: fields["Certification Levels (from Montessori Certifications)"] || undefined,
      certifier: fields["Certifier (from Montessori Certifications)"] || undefined,
      montessoriLeadGuideTrainings: fields["Montessori lead guide trainings"] || undefined,
      currentRole: fields["Current Role"] || undefined,
      discoveryStatus: fields["Discovery status"] || undefined,
      assignedPartner: fields["Assigned Partner"] || undefined,
      assignedPartnerEmail: fields["Assigned Partner Email"] || undefined,
      householdIncome: fields["Household Income"] || undefined,
      incomeBackground: fields["Income Background"] || undefined,
      individualType: fields["Individual Type"] || undefined,
      onboardingExperience: fields["Onboarding Experience"] || undefined,
      currentlyActiveAtSchool: fields["Currently Active at a School?"] ? fields["Currently Active at a School?"][0] === "Yes" : undefined,
      allSchools: fields["All Schools"] || undefined,
      currentlyActiveSchool: fields["Currently Active School"] || undefined,
      schoolStatuses: fields["School Statuses"] || undefined,
      startupStageForActiveSchool: fields["Startup Stage for Active School"] || undefined,
      targetCity: fields["Target city"] || undefined,
      firstContactWFSchoolEmploymentStatus: fields["First contact - WF School employment status"] || undefined,
      firstContactNotesOnPreWildflowerEmployment: fields["First contact - Notes on pre-Wildflower employment"] || undefined,
      firstContactInitialInterestInGovernanceModel: fields["First contact - Initial Interest in Governance Model"] || undefined,
      activeHolaspirit: fields["Active Holaspirit"] || false,
      holaspiritMemberID: fields["Holaspirit memberID"] || undefined,
      tcUserID: fields["TC User ID"] || undefined,
      alsoAPartner: fields["Also a partner"] || false,
      onSchoolBoard: fields["On school board"] || undefined,
      everATLInAnOpenSchool: fields["Ever a TL in an open school"] || false,
      created: fields["Created"] || undefined,
      lastModified: fields["Last Modified"] || undefined,
      createdBy: fields["Created By"]?.name || undefined,
    };
  }

  // Helper method to transform Airtable record to School
  private transformSchoolRecord(record: any): School {
    const fields = record.fields;
    return {
      id: record.id,
      name: fields["Name"] || fields["School Name"] || "",
      shortName: fields["Short Name"] || undefined,
      fullName: fields["Full Name"] || undefined,
      address: fields["Address"] || undefined,
      city: fields["City"] || undefined,
      state: fields["State"] || undefined,
      zipCode: fields["ZIP Code"] || fields["Zip Code"] || undefined,
      targetCommunity: fields["Target community"] || undefined,
      phone: fields["Phone"] || undefined,
      email: fields["Email"] || undefined,
      website: fields["Website"] || undefined,
      grades: fields["Grades"] || undefined,
      agesServed: fields["Ages served"] || undefined,
      schoolType: fields["School Type"] || fields["Type"] || undefined,
      governanceModel: fields["Governance Model"] || undefined,
      status: fields["Status"] || undefined,
      openDate: fields["Open Date"] || undefined,
      targetOpenDate: fields["Target Open Date"] || undefined,
      enrollmentCap: fields["Enrollment Cap"] || undefined,
      currentEnrollment: fields["Current Enrollment"] || undefined,
      tuitionRange: fields["Tuition Range"] || undefined,
      membershipFeeStatus: fields["Membership Fee Status"] || undefined,
      membershipFeeAmount: fields["Membership Fee Amount"] || undefined,
      publicFunding: fields["Public Funding"] || false,
      charterStatus: fields["Charter Status"] || undefined,
      authorizer: fields["Authorizer"] || undefined,
      demographics: fields["Demographics"] || undefined,
      assessmentData: fields["Assessment Data"] || undefined,
      latitude: fields["Latitude"] || undefined,
      longitude: fields["Longitude"] || undefined,
      timezone: fields["Timezone"] || undefined,
      created: fields["Created"] || undefined,
      lastModified: fields["Last Modified"] || undefined,
      createdBy: fields["Created By"]?.name || undefined,
    };
  }

  // Educator operations
  async getEducators(): Promise<Educator[]> {
    try {
      const records = await base("Educators").select().all();
      return records.map(record => this.transformEducatorRecord(record));
    } catch (error) {
      console.error("Error fetching educators from Airtable:", error);
      throw error;
    }
  }

  async getEducator(id: string): Promise<Educator | undefined> {
    try {
      const record = await base("Educators").find(id);
      return this.transformEducatorRecord(record);
    } catch (error) {
      console.error(`Error fetching educator ${id} from Airtable:`, error);
      return undefined;
    }
  }

  async getEducatorByEmail(email: string): Promise<Educator | undefined> {
    try {
      const records = await base("Educators").select({
        filterByFormula: `{Primary email} = "${email}"`
      }).all();
      
      if (records.length > 0) {
        return this.transformEducatorRecord(records[0]);
      }
      return undefined;
    } catch (error) {
      console.error(`Error fetching educator by email ${email} from Airtable:`, error);
      return undefined;
    }
  }

  async createEducator(educator: InsertEducator): Promise<Educator> {
    try {
      const record = await base("Educators").create({
        "First Name": educator.firstName,
        "Last Name": educator.lastName,
        "Middle Name": educator.middleName,
        "Nickname": educator.nickname,
        "Primary phone": educator.primaryPhone,
        "Secondary phone": educator.secondaryPhone,
        "Home Address": educator.homeAddress,
        "Pronouns": educator.pronouns,
        "Gender": educator.gender,
        "Race & Ethnicity": educator.raceEthnicity,
        "Primary Language": educator.primaryLanguage,
        "Other languages": educator.otherLanguages,
        "Educational Attainment": educator.educationalAttainment,
        "Montessori lead guide trainings": educator.montessoriLeadGuideTrainings,
        "Household Income": educator.householdIncome,
        "Income Background": educator.incomeBackground,
        "Individual Type": educator.individualType,
        "Onboarding Experience": educator.onboardingExperience,
        "Target city": educator.targetCity,
        "First contact - WF School employment status": educator.firstContactWFSchoolEmploymentStatus,
        "First contact - Notes on pre-Wildflower employment": educator.firstContactNotesOnPreWildflowerEmployment,
        "First contact - Initial Interest in Governance Model": educator.firstContactInitialInterestInGovernanceModel,
        "Active Holaspirit": educator.activeHolaspirit,
        "Holaspirit memberID": educator.holaspiritMemberID,
        "TC User ID": educator.tcUserID,
        "Also a partner": educator.alsoAPartner,
        "On school board": educator.onSchoolBoard,
      });
      
      return this.transformEducatorRecord(record);
    } catch (error) {
      console.error("Error creating educator in Airtable:", error);
      throw error;
    }
  }

  async updateEducator(id: string, educator: Partial<InsertEducator>): Promise<Educator | undefined> {
    try {
      const updateFields: any = {};
      
      if (educator.firstName !== undefined) updateFields["First Name"] = educator.firstName;
      if (educator.lastName !== undefined) updateFields["Last Name"] = educator.lastName;
      if (educator.middleName !== undefined) updateFields["Middle Name"] = educator.middleName;
      if (educator.nickname !== undefined) updateFields["Nickname"] = educator.nickname;
      if (educator.primaryPhone !== undefined) updateFields["Primary phone"] = educator.primaryPhone;
      if (educator.secondaryPhone !== undefined) updateFields["Secondary phone"] = educator.secondaryPhone;
      if (educator.homeAddress !== undefined) updateFields["Home Address"] = educator.homeAddress;
      if (educator.pronouns !== undefined) updateFields["Pronouns"] = educator.pronouns;
      if (educator.gender !== undefined) updateFields["Gender"] = educator.gender;
      if (educator.raceEthnicity !== undefined) updateFields["Race & Ethnicity"] = educator.raceEthnicity;
      if (educator.primaryLanguage !== undefined) updateFields["Primary Language"] = educator.primaryLanguage;
      if (educator.otherLanguages !== undefined) updateFields["Other languages"] = educator.otherLanguages;
      if (educator.educationalAttainment !== undefined) updateFields["Educational Attainment"] = educator.educationalAttainment;
      if (educator.montessoriLeadGuideTrainings !== undefined) updateFields["Montessori lead guide trainings"] = educator.montessoriLeadGuideTrainings;
      if (educator.householdIncome !== undefined) updateFields["Household Income"] = educator.householdIncome;
      if (educator.incomeBackground !== undefined) updateFields["Income Background"] = educator.incomeBackground;
      if (educator.individualType !== undefined) updateFields["Individual Type"] = educator.individualType;
      if (educator.onboardingExperience !== undefined) updateFields["Onboarding Experience"] = educator.onboardingExperience;
      if (educator.targetCity !== undefined) updateFields["Target city"] = educator.targetCity;
      if (educator.firstContactWFSchoolEmploymentStatus !== undefined) updateFields["First contact - WF School employment status"] = educator.firstContactWFSchoolEmploymentStatus;
      if (educator.firstContactNotesOnPreWildflowerEmployment !== undefined) updateFields["First contact - Notes on pre-Wildflower employment"] = educator.firstContactNotesOnPreWildflowerEmployment;
      if (educator.firstContactInitialInterestInGovernanceModel !== undefined) updateFields["First contact - Initial Interest in Governance Model"] = educator.firstContactInitialInterestInGovernanceModel;
      if (educator.activeHolaspirit !== undefined) updateFields["Active Holaspirit"] = educator.activeHolaspirit;
      if (educator.holaspiritMemberID !== undefined) updateFields["Holaspirit memberID"] = educator.holaspiritMemberID;
      if (educator.tcUserID !== undefined) updateFields["TC User ID"] = educator.tcUserID;
      if (educator.alsoAPartner !== undefined) updateFields["Also a partner"] = educator.alsoAPartner;
      if (educator.onSchoolBoard !== undefined) updateFields["On school board"] = educator.onSchoolBoard;

      const record = await base("Educators").update(id, updateFields);
      return this.transformEducatorRecord(record);
    } catch (error) {
      console.error(`Error updating educator ${id} in Airtable:`, error);
      return undefined;
    }
  }

  async deleteEducator(id: string): Promise<boolean> {
    try {
      await base("Educators").destroy(id);
      return true;
    } catch (error) {
      console.error(`Error deleting educator ${id} from Airtable:`, error);
      return false;
    }
  }

  // School operations
  async getSchools(): Promise<School[]> {
    try {
      const records = await base("Schools").select().all();
      return records.map(record => this.transformSchoolRecord(record));
    } catch (error) {
      console.error("Error fetching schools from Airtable:", error);
      throw error;
    }
  }

  async getSchool(id: string): Promise<School | undefined> {
    try {
      const record = await base("Schools").find(id);
      return this.transformSchoolRecord(record);
    } catch (error) {
      console.error(`Error fetching school ${id} from Airtable:`, error);
      return undefined;
    }
  }

  async createSchool(school: InsertSchool): Promise<School> {
    try {
      const record = await base("Schools").create({
        "Name": school.name,
        "Short Name": school.shortName,
        "Full Name": school.fullName,
        "Address": school.address,
        "City": school.city,
        "State": school.state,
        "ZIP Code": school.zipCode,
        "Target community": school.targetCommunity,
        "Phone": school.phone,
        "Email": school.email,
        "Website": school.website,
        "Grades": school.grades,
        "Ages served": school.agesServed,
        "School Type": school.schoolType,
        "Governance Model": school.governanceModel,
        "Status": school.status,
        "Open Date": school.openDate,
        "Target Open Date": school.targetOpenDate,
        "Enrollment Cap": school.enrollmentCap,
        "Current Enrollment": school.currentEnrollment,
        "Tuition Range": school.tuitionRange,
        "Membership Fee Status": school.membershipFeeStatus,
        "Membership Fee Amount": school.membershipFeeAmount,
        "Public Funding": school.publicFunding,
        "Charter Status": school.charterStatus,
        "Authorizer": school.authorizer,
        "Latitude": school.latitude,
        "Longitude": school.longitude,
        "Timezone": school.timezone,
      });
      
      return this.transformSchoolRecord(record);
    } catch (error) {
      console.error("Error creating school in Airtable:", error);
      throw error;
    }
  }

  async updateSchool(id: string, school: Partial<InsertSchool>): Promise<School | undefined> {
    try {
      const updateFields: any = {};
      
      if (school.name !== undefined) updateFields["Name"] = school.name;
      if (school.shortName !== undefined) updateFields["Short Name"] = school.shortName;
      if (school.fullName !== undefined) updateFields["Full Name"] = school.fullName;
      if (school.address !== undefined) updateFields["Address"] = school.address;
      if (school.city !== undefined) updateFields["City"] = school.city;
      if (school.state !== undefined) updateFields["State"] = school.state;
      if (school.zipCode !== undefined) updateFields["ZIP Code"] = school.zipCode;
      if (school.targetCommunity !== undefined) updateFields["Target community"] = school.targetCommunity;
      if (school.phone !== undefined) updateFields["Phone"] = school.phone;
      if (school.email !== undefined) updateFields["Email"] = school.email;
      if (school.website !== undefined) updateFields["Website"] = school.website;
      if (school.grades !== undefined) updateFields["Grades"] = school.grades;
      if (school.agesServed !== undefined) updateFields["Ages served"] = school.agesServed;
      if (school.schoolType !== undefined) updateFields["School Type"] = school.schoolType;
      if (school.governanceModel !== undefined) updateFields["Governance Model"] = school.governanceModel;
      if (school.status !== undefined) updateFields["Status"] = school.status;
      if (school.openDate !== undefined) updateFields["Open Date"] = school.openDate;
      if (school.targetOpenDate !== undefined) updateFields["Target Open Date"] = school.targetOpenDate;
      if (school.enrollmentCap !== undefined) updateFields["Enrollment Cap"] = school.enrollmentCap;
      if (school.currentEnrollment !== undefined) updateFields["Current Enrollment"] = school.currentEnrollment;
      if (school.tuitionRange !== undefined) updateFields["Tuition Range"] = school.tuitionRange;
      if (school.membershipFeeStatus !== undefined) updateFields["Membership Fee Status"] = school.membershipFeeStatus;
      if (school.membershipFeeAmount !== undefined) updateFields["Membership Fee Amount"] = school.membershipFeeAmount;
      if (school.publicFunding !== undefined) updateFields["Public Funding"] = school.publicFunding;
      if (school.charterStatus !== undefined) updateFields["Charter Status"] = school.charterStatus;
      if (school.authorizer !== undefined) updateFields["Authorizer"] = school.authorizer;
      if (school.latitude !== undefined) updateFields["Latitude"] = school.latitude;
      if (school.longitude !== undefined) updateFields["Longitude"] = school.longitude;
      if (school.timezone !== undefined) updateFields["Timezone"] = school.timezone;

      const record = await base("Schools").update(id, updateFields);
      return this.transformSchoolRecord(record);
    } catch (error) {
      console.error(`Error updating school ${id} in Airtable:`, error);
      return undefined;
    }
  }

  async deleteSchool(id: string): Promise<boolean> {
    try {
      await base("Schools").destroy(id);
      return true;
    } catch (error) {
      console.error(`Error deleting school ${id} from Airtable:`, error);
      return false;
    }
  }

  // Educator-School Association operations
  async getEducatorSchoolAssociations(): Promise<EducatorSchoolAssociation[]> {
    try {
      const records = await base("Educators x Schools").select().all();
      return records.map(record => this.transformAssociationRecord(record));
    } catch (error) {
      console.error("Error fetching educator-school associations from Airtable:", error);
      throw error;
    }
  }

  async getEducatorAssociations(educatorId: string): Promise<EducatorSchoolAssociation[]> {
    try {
      const records = await base("Educators x Schools").select({
        filterByFormula: `{Educator} = "${educatorId}"`
      }).all();
      
      return records.map(record => this.transformAssociationRecord(record));
    } catch (error) {
      console.error(`Error fetching associations for educator ${educatorId} from Airtable:`, error);
      throw error;
    }
  }

  async getSchoolAssociations(schoolId: string): Promise<EducatorSchoolAssociation[]> {
    try {
      const records = await base("Educators x Schools").select({
        filterByFormula: `{School} = "${schoolId}"`
      }).all();
      
      return records.map(record => this.transformAssociationRecord(record));
    } catch (error) {
      console.error(`Error fetching associations for school ${schoolId} from Airtable:`, error);
      throw error;
    }
  }

  async createEducatorSchoolAssociation(association: InsertEducatorSchoolAssociation): Promise<EducatorSchoolAssociation> {
    try {
      const record = await base("Educators x Schools").create({
        "Educator": [association.educatorId],
        "School": [association.schoolId],
        "Role": association.role,
        "Status": association.status,
        "Start Date": association.startDate,
        "End Date": association.endDate,
        "Is Primary": association.isPrimary,
        "Is Active": association.isActive,
      });
      
      return this.transformAssociationRecord(record);
    } catch (error) {
      console.error("Error creating educator-school association in Airtable:", error);
      throw error;
    }
  }

  private transformAssociationRecord(record: any): EducatorSchoolAssociation {
    const fields = record.fields;
    return {
      id: record.id,
      educatorId: Array.isArray(fields["Educator"]) ? fields["Educator"][0] : "",
      schoolId: Array.isArray(fields["School"]) ? fields["School"][0] : "",
      role: typeof fields["Role"] === 'string' ? fields["Role"] : undefined,
      status: typeof fields["Status"] === 'string' ? fields["Status"] : undefined,
      startDate: typeof fields["Start Date"] === 'string' ? fields["Start Date"] : undefined,
      endDate: typeof fields["End Date"] === 'string' ? fields["End Date"] : undefined,
      isPrimary: typeof fields["Is Primary"] === 'boolean' ? fields["Is Primary"] : false,
      isActive: typeof fields["Is Active"] === 'boolean' ? fields["Is Active"] : false,
      created: typeof fields["Created"] === 'string' ? fields["Created"] : undefined,
      lastModified: typeof fields["Last Modified"] === 'string' ? fields["Last Modified"] : undefined,
    };
  }

  async deleteEducatorSchoolAssociation(id: string): Promise<boolean> {
    try {
      await base("Educators x Schools").destroy(id);
      return true;
    } catch (error) {
      console.error(`Error deleting educator-school association ${id} from Airtable:`, error);
      return false;
    }
  }

  // Legacy methods for backward compatibility
  async getTeachers(): Promise<Teacher[]> {
    return this.getEducators();
  }

  async getTeacher(id: string): Promise<Teacher | undefined> {
    return this.getEducator(id);
  }

  async getTeacherByEmail(email: string): Promise<Teacher | undefined> {
    return this.getEducatorByEmail(email);
  }

  async createTeacher(teacher: InsertTeacher): Promise<Teacher> {
    return this.createEducator(teacher);
  }

  async updateTeacher(id: string, teacher: Partial<InsertTeacher>): Promise<Teacher | undefined> {
    return this.updateEducator(id, teacher);
  }

  async deleteTeacher(id: string): Promise<boolean> {
    return this.deleteEducator(id);
  }

  async getTeacherSchoolAssociations(): Promise<TeacherSchoolAssociation[]> {
    return this.getEducatorSchoolAssociations();
  }

  async getTeacherAssociations(teacherId: string): Promise<TeacherSchoolAssociation[]> {
    return this.getEducatorAssociations(teacherId);
  }

  async createTeacherSchoolAssociation(association: InsertTeacherSchoolAssociation): Promise<TeacherSchoolAssociation> {
    return this.createEducatorSchoolAssociation(association);
  }

  async deleteTeacherSchoolAssociation(id: string): Promise<boolean> {
    return this.deleteEducatorSchoolAssociation(id);
  }
}

export const storage = new AirtableStorage();
